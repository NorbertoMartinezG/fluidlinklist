//import 'dart:ffi';
//import 'dart:ffi';
//import 'dart:ffi';
//import 'dart:ffi';
import 'dart:math';
import 'package:flutter/foundation.dart';
import 'package:flutter/widgets.dart';
import 'package:flutter/animation.dart';
import 'package:flutter/material.dart';
import 'package:vector_math/vector_math.dart' hide Colors; // Colors esta definida tanto en libreria material como en Vector

import 'package:sensors_plus/sensors_plus.dart';

import 'package:flutter/services.dart'; // para evitar rotacion entre otros

// SPH fluid
main() {
  
  WidgetsFlutterBinding.ensureInitialized();// para evitar que gire la pantalla agregar libreria services
  SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp])// para evitar que gire la pantalla agregar libreria services
    .then((_) {// para evitar que gire la pantalla agregar libreria services
      runApp(new MaterialApp(home: new DemoPage()));
      });

}

class DemoPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    assert(debugCheckHasMediaQuery(context));
    return new Scaffold(
      body: new DemoBody(
        screenSize: MediaQuery.of(context).size,
      ),
    );
  }
}

class DemoBody extends StatefulWidget {
  final Size screenSize;

  DemoBody({Key key, @required this.screenSize}) : super(key: key);

  @override
  State<StatefulWidget> createState() {
    return new _DemoBodyState();
  }
}


class _DemoBodyState extends State<DemoBody> with TickerProviderStateMixin {
  AnimationController animationController;
  final nodeList = <Node>[];
  
  final numNodes = 10*10; // ********************************************
  final int MAX_NEIGHBORS = 32;
  
  final genericParticles1 = <GenericParticle>[];
  //final genericParticles2 = <GenericParticle>[];


  //   final nodeList = <Node>[]; // Particles
  //final sub_nh = <Node>[]; // Sub Particulas para integrar a lista neighborhoodList dentro de Neighborhood nh
  final nh = <Neighborhood>[]; // Neighbors
  final grid = <GenericParticle>[]; // Particles
  final grid0 = <GenericParticle>[]; // Particles

  double gyroX = 0;
  double gyroY = 0;
  double gyroZ = 0;

  @override
  void initState() {
    super.initState();

    
      // Para interaccion con girospio, acelerometro, // ESTO SOLO FUNCIONA CUANDO SE SELECCIONA EL EMULADOR pixel 3 XL API 29
      gyroscopeEvents.listen((GyroscopeEvent event) { // agregar libreria sensor_plus.dart
      setState(() {

        gyroX = event.x;
        gyroY = event.y;
        gyroZ = event.z;
      });
    });
    
     
    
    double REST_DENS = 1000.0; // densidad en reposo
    double GAS_CONST = 2000.0; // const for equation of state

    double MASS = 65.0; // assume all particles have the same mass
    double VISC = 250.0; // viscosity constant

    double BOUND_DAMPING = -0.5; // amortiguacion 
    //Offset G = Offset(0.0, 12000 * 9.8);

// Variables pcisph
    double PARTICLE_RADIUS = 0.6; // 0.03 valor original
    double H = 6.2 * PARTICLE_RADIUS; // kernel radius 6 * PARTICLE RADIUS = 0.18
    double HSQ = H * H; // radius^2 for optimization
    double CELL_SIZE = H;
    
    //double VIEW_WIDTH = 20.0; // original 20
    double VIEW_WIDTH_d = widget.screenSize.width; // original 20
    int VIEW_WIDTH_i =VIEW_WIDTH_d.floor();
    double VIEW_WIDTH = VIEW_WIDTH_i.toDouble();
    print(VIEW_WIDTH); // 411

    //double VIEW_HEIGHT = widget.screenSize.height.ceil() * VIEW_WIDTH / widget.screenSize.width.ceil();
    double VIEW_HEIGHT_d = widget.screenSize.height;
    int VIEW_HEIGHT_i = VIEW_HEIGHT_d.floor();
    double VIEW_HEIGHT =VIEW_HEIGHT_i.toDouble();
    print(VIEW_HEIGHT); //797


    int GRID_WIDTH = (VIEW_WIDTH / CELL_SIZE).ceil();
    print(GRID_WIDTH);
    int GRID_HEIGHT = (VIEW_HEIGHT / CELL_SIZE).ceil();
    print(GRID_HEIGHT);
    int NUM_CELLS = GRID_WIDTH * GRID_HEIGHT;
    print("NUM_CELLS");
    print(NUM_CELLS);
    print("CELL_SIZE");
    print(CELL_SIZE);
    print("particle size");
    print(0.5 * PARTICLE_RADIUS * widget.screenSize.width / VIEW_WIDTH); // tamaño de la particula)
    
    double spacing = PARTICLE_RADIUS  ; // al modificar este valor se evita el 0
    
    

    double POLY6 = 315.0 / (65.0 * 3.1416 * pow(H, 9.0)); // El núcleo poly6 también se conoce como núcleo polinomial de sexto grado. 
    int SOLVER_STEPS = 2;

    int MAX_PARTICLES = numNodes;
    var gridIndices = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector inicializados en 0
    var xlast = List<Offset>.filled(numNodes, Offset(0.0,0.0)); // lista con 5 elementos tipo offset inicializado en 0
    double EPS = 0.0000001;
    double EPS2 = EPS * EPS;
    double KERN = 20.0 / (2.0 * 5.0 * H * H);
    double KERN_NORM = 30.0 / (2.0 * 5.0 * H * H);
    double STIFFNESS = 0.08;
    double REST_DENSITY = 45.0;
    double STIFF_APPROX = 0.1;
    
    int fps = 40;
    
    double DT = ((1.0 / fps) / SOLVER_STEPS);
    Offset g = Offset(0.0, 9.81); // -9.81 valor original
    double DT2 = DT * DT;
    double SURFACE_TENSION = 0.000001;
    double LINEAR_VISC = 10.25;
    double QUAD_VISC = 0.05;
    var xprojected = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector2 inicializados en 0
    //var boundaries = List<Vector3>.filled(MAX_PARTICLES, Vector3(0.0,0.0,0.0)); // lista con 25 elementos tipo vector3 inicializados en 0
    List<Vector3> boundaries = [];
    
    // valores originales
    // boundaries.add(Vector3(1, 0, 0));
    // boundaries.add(Vector3(0, 1, 0));
    // boundaries.add(Vector3(-1, 0, -VIEW_WIDTH));
    // boundaries.add(Vector3(0, -1, -VIEW_HEIGHT));

    boundaries.add(Vector3(1, 0, 0));
    boundaries.add(Vector3(0, 1, 0));
    boundaries.add(Vector3(-1, 0, -VIEW_WIDTH));
    boundaries.add(Vector3(0, -1, -VIEW_HEIGHT));

//COMENTAR ESTA PARTE ORIGINAL
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///

//----------------------------------------------------------------------------------
    //print(NUM_CELLS); //23865
    //print(GRID_HEIGHT); //215
    //print(GRID_WIDTH); //111
    //print(CELL_SIZE); // 0.18
    // double VIEW_WIDTH = 20.0; // original 5
    // double VIEW_HEIGHT = widget.screenSize.height.ceil() * VIEW_WIDTH / widget.screenSize.width.ceil();
    // int GRID_WIDTH = (VIEW_WIDTH / CELL_SIZE).ceil();
    // int GRID_HEIGHT = (VIEW_HEIGHT / CELL_SIZE).ceil(); 
    // print(VIEW_HEIGHT);
    // print(GRID_WIDTH);
    // print(GRID_HEIGHT);
    // print("view_height"); //
    // print(widget.screenSize.height.ceil()* VIEW_WIDTH / widget.screenSize.width.ceil()); // 0.18
    //var listaxy = List<Vector2>.filled(numNodes, Vector2(0.0,0.0)); // lista con 5 elementos tipo offset inicializado en  
    var listaxy = [];
    int num = sqrt(numNodes).ceil();

    
    double x = 0.5 * VIEW_WIDTH;
    //double y = 0.5 * VIEW_HEIGHT;
    //print(x0);
    
    for (double i = 0, y = 0.5 * VIEW_HEIGHT; i < num; i++, y -= 2 * PARTICLE_RADIUS + spacing) // recorre todas las particulas para acomodarlas en rompimiento de presa.
    {

        for (int j = 0; j < num; j++) // aqui se actuliza valor y, dentro no lo reconoce
        {

            listaxy.add([x,y]);
  
            
            x += 2.0 * PARTICLE_RADIUS + spacing ; // actualiza valor de primera posicion del vector start sumando esta operacion 
 
        }
        x = 0.5 * VIEW_WIDTH; // resetea posicion x
 

    }
    
    //print(listaxy);

    
    // INICIALIZACION PARTICULAS principales---------------------------------------------------------------------------------------------------------

    Iterable.generate(numNodes).forEach((i) { // inicializacion de particulas
      
      double valx = (listaxy[i][0]); // variable para posicion inicial en x
      double valy = (listaxy[i][1]); // variable para posicion inicial en y

       nodeList.add( // inicializacion de valores no inicializados en la calse Node
        new Node(
          id: i, 
          screenSize: widget.screenSize, 
          //size: 6 * PARTICLE_RADIUS * widget.screenSize.width / VIEW_WIDTH, // tamaño de la particula
          size: 6 * PARTICLE_RADIUS * widget.screenSize.width / VIEW_WIDTH, // tamaño de la particula
          position: Offset(valx, valy),
          velocidad: Offset(0.0, 0.0),
          
          )
        );
      } 
    );
// INICIALIZACION PARTICULAS fin ---------------------------------------------------------------------------------------------------------

// INICIALIZACION PATICULAS GENERICAS PARA ESPEJO DE PARTICULAS PRINCIPALES

 Iterable.generate(numNodes).forEach((i) { // inicializacion de particulas  

      double valx = (listaxy[i][0]); // variable para posicion inicial en x
      double valy = (listaxy[i][1]); // variable para posicion inicial en y

      
      genericParticles1.add( // inicializacion de valores no inicializados en la calse Node
        new GenericParticle
          ( position: Offset(valx, valy),
            velocidad: Offset(0.0, 0.0),
            //n1:GenericParticle( position: Offset(0.0, 0.0), velocidad: Offset(0.0, 0.0)), // opcional
            )
        );
      } 
    );


// INICIALIZACION PARTICULAS GRID ---------------------------------------------------------------------------------------------------------


 Iterable.generate(NUM_CELLS).forEach((i) { // inicializacion de particulas  
      grid0.add( // inicializacion de valores no inicializados en la calse Node
        new GenericParticle
          ( position: Offset(0.0, 0.0), 
            velocidad: Offset(0.0, 0.0),
            //n1:GenericParticle( position: Offset(0.0, 0.0), velocidad: Offset(0.0, 0.0)),
            )
        );
      } 
    );

// INICIALIZACION vecinos numNeighbors---------------------------------------------------------------------------------------------------------

    Iterable.generate(numNodes).forEach((i) { // inicializacion de particulas
      
      nh.add( // inicializacion de valores no inicializados en la calse Node
        new Neighborhood(
                    position: Offset(0.0, 0.0),
                    velocidad: Offset(0.0, 0.0),
                    r: List<double>.filled(numNodes, 0.0),
                    neighborhoodList: List<GenericParticle>.filled(numNodes, // 64 vecinos tipo ParticlesNeighborhood // neighborhoodList es una lista a la que se le asigna otra lista de varios elementos ya inicializados          
                            GenericParticle( 
                                            position: Offset(0.0, 0.0),
                                            velocidad: Offset(0.0, 0.0),
                                            )
                                                        )
                         ), 

        );
      } 
    );
// INICIALIZACION vecinos fin ---------------------------------------------------------------------------------------------------------
// for (var i = 0; i < grid.length; i++) {
  
//  grid[1].n1 = GenericParticle(position: Offset(0.0, 0.0), velocidad: Offset(0.0, 0.0));
  
//   if (grid[i].n1 == null) 
//   {
//     print("Es NULL");    
//     //print(genericParticles1[i].n1.position);    
//   } else {
//           print("no es NULL"); 
//           //print(genericParticles1[i].n1.position);    
//          }
// }


// ---------------------------------------------------------------- INICIALIZAR GRIDINSERT ---------------------------------------------------------------------------------------------------------


        //   for (int i=0 ,j = MAX_PARTICLES; i < nodeList.length; i++,j++){
        //     int indice = j-MAX_PARTICLES;  
        //     double px = genericParticles1[i].position.dx / CELL_SIZE;
        //     int xind = px.toInt();
        //        //     double py = genericParticles1[i].position.dy / CELL_SIZE;
        //     //int yind = py.floor();
        //     int yind = py.toInt();
        //     xind = max(1,(min(GRID_WIDTH - 2, xind)));
        //     yind = max(1,(min(GRID_HEIGHT - 2, yind)));
        //     //print(xind);
        //     //print(yind);
        //     genericParticles1[i].n1 = grid[xind+yind*GRID_WIDTH].n1; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
        //     // print(xind+yind*GRID_WIDTH);
        //     if (genericParticles1[i].n1 == null) {
        //       print(" grid null");              
        //     } else {
        //       print(" grid no null");
        //     }            
        //     grid[xind+yind*GRID_WIDTH].n1 = genericParticles1[i];
        //     gridIndices[indice] = Vector2(xind.toDouble(), yind.toDouble()); //var gridIndices = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector inicializados en 0
        //   }
        //   //print("*******************gridIndices***********************");
        //  print(gridIndices);

void move(){


  for (int i = 0; i < SOLVER_STEPS; i++) 
  {
    //print("*********************************primer ciclo*********************************");

//--------// ApplyExternalForces
          for (int j = 0; j < genericParticles1.length; j++) {
            genericParticles1[j].velocidad += g* DT;
          }

          
 //------// Integrate
          for (int j = 0; j < genericParticles1.length; j++){
            //var p = nodeList[i]; // toma una particula
            xlast[j] = genericParticles1[j].position; //guarda posicion de particula actual(i)
            //print('xlast--- $xlast');
            //print('xlast---');
            //double xlasx = xlast[i].dx;
            //print(xlasx);
            //double xlasy = xlast[i].dy;
            //print(xlasy);
            
            genericParticles1[j].position += genericParticles1[j].velocidad * DT ; //  suma y actualiza posicion debida a la velocidad y tiempo 
            //print('genericParticles1[i].position---');
            //double posx = genericParticles1[i].position.dx;
            //print(posx);
            //double posy = genericParticles1[i].position.dy;
            //print(posy);
          }

  //*******************************************************************AQUI REVISADO************ */

          //print("--------------fin primer ciclo integrate--------------");

//------------------------------// GridInsert

          //print("--------------INICIO ciclo GRIDINSERT--------------");
         
          grid.clear();
            
           Iterable.generate(NUM_CELLS).forEach((k) { // inicializacion de particulas  
                    grid.add( // inicializacion de valores no inicializados en la calse Node
                      new GenericParticle
                        ( position: Offset(0.0, 0.0), 
                          velocidad: Offset(0.0, 0.0),
                          //n1:GenericParticle( position: Offset(0.0, 0.0), velocidad: Offset(0.0, 0.0)),
                          )
                      );
                    } 
                  );
         
          for (int j=0 ,k = MAX_PARTICLES; j < genericParticles1.length; j++,k++){

            
            int indice = k-MAX_PARTICLES;  
    
            double px = (genericParticles1[j].position.dx / CELL_SIZE);//escala posicion al grid dividiendo entre cell size para quedar en un rango entre 0 y 111 en coordenada X de la coleccion grid
 
           
            int xind = px.ceil();
            //int xind = xind1.ceil();
            //print("xind---------$xind");
           

            double py = (genericParticles1[j].position.dy / CELL_SIZE);

            //int yind = py.floor();
            int yind = py.ceil();
            //int yind = yind1.toceil();
            //print("yind---------$yind");

            xind = max(1,(min(GRID_WIDTH - 2, xind))); // si xind esta al borde toma la posicion extrema a lo ancho y le resta 2 posiciones para poder evaluar los vecinos de todos los lados
            yind = max(1,(min(GRID_HEIGHT - 2, yind)));
            //print("xindMax---------$xind");
            //print("yindMax---------$yind");
            
            //print(xind.toDouble()); //**--
            //print(yind.toDouble()); //**--
            //print((xind+yind*GRID_WIDTH).toDouble()); // 22671 -- 22672 -- 22671 -- 22672 **--
            //print("hola que hace");

            
            

         
            genericParticles1[j].n1 = grid[xind+yind*GRID_WIDTH].n1; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
            //print(genericParticles1[i].n.nulidad);
            // if (genericParticles1[i].n1 == null) {
            //   print(" grid null");
              
            // } else {
            //   print(" grid no null");
            // }
           // print(xind+yind*GRID_WIDTH);
            
            grid[xind+yind*GRID_WIDTH].n1 = genericParticles1[j];
            
            //genericParticles1[i].n1 = grid[xind+yind*GRID_WIDTH].n1; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
           // print(xind+yind*GRID_WIDTH);
            

            
            gridIndices[indice] = Vector2(xind.toDouble(), yind.toDouble()); //va

          }
          //print("--------------FIN ciclo GRIDINSERT--------------");

//------------------------------// PressureStep
          //print("--------------INICIO ciclo PRESSURESTEP--------------");
          for (int j = 0; j < genericParticles1.length; j++)
          {
            //print("--------------INICIO CICLO INTERNO FOR PRESURESTEP--------------");
            //var p_i = nodeList[i]; // toma una particula
            Vector2 ind = Vector2(gridIndices[j][0],(gridIndices[j][1]) * GRID_WIDTH);
            // print("ind[0]");
            // print(ind[0]);
            // print("ind[1]");
            nh[j].numNeighbors = 0;
            
            double dens = 0.0;
            double dens_proj = 0.0;

            
            for (int ii = ind[0].ceil() - 1; ii <= ind[0] + 1; ii++) //
            {
              //print("[ii]****");
               // print(ii);
                
                for (int jj = ind[1].ceil() - GRID_WIDTH; jj <= ind[1] + GRID_WIDTH; jj += GRID_WIDTH)
                { //static const int GRID_WIDTH = (int)(VIEW_WIDTH / CELL_SIZE); = 111 // static const static double VIEW_WIDTH = 20.0f;// const double CELL_SIZE = H; // const static double H = 6.0f * PARTICLE_RADIUS; //
               // print("jj****");
               // print(jj);
       
                    for (GenericParticle pgrid = grid[ii+jj].n1; pgrid != null; pgrid= pgrid.n1) // asigna a particula nueva pgrid el valor de particula grid que antes guardo valores de las particulas generales == static vector<Particle*> grid(NUM_CELLS); // static const int NUM_CELLS = GRID_WIDTH * GRID_HEIGHT;
                    { // para la particula ubicada en ii+jj, hasta que pgrid sea nulo, todas las particulas linkadas a esa particula
                        // ejemplo de logica usada en este for
                           
                           //print(pgrid.position);
                            // int grid = 11;
                            // print(ii);
                            // print(jj);
                            // print(ii+jj);
                            // print("grid[ii+jj]");
                            // print(grid[ii+jj]);
                            
                        //Offset dx_offset = p_j.position - p_i.position;
                        Offset dx_offset = pgrid.position - genericParticles1[j].position;
                        Vector2 dx = Vector2(dx_offset.dx, dx_offset.dy); // convertir offset a vector
                       // print("dx[0]");
                       // print(dx[0]);
                       // print("dx[1]");
                        //print(dx[1]);
                        
                        double r2 = dx[0]*dx[0] + dx[1]*dx[1] ; // suma del cuadrado de todas las entradas de la matriz.
                       // print("r2--------$r2");
                        
                        // si r2 < EPS2 = true O si r2 > H * H continua la proxima
                        if (r2 < EPS2 || r2 > H * H){continue;} // termina iteracion for actual y va con la siguiente
                        
                        double r = sqrt(r2);
                        //print("r--------$r");
                        double a = 1.0 - r / H;
                        //print("a--------$a");
                        dens += pgrid.masa * a * a * a * KERN;
                       // print("dens--------$dens");
                        //dens_proj += p_j.masa * a * a * a * a * KERN_NORM;
                        dens_proj += pgrid.masa * a * a * a * a * KERN_NORM;
                        //print("dens_proj--------$dens_proj");

                        if (nh[j].numNeighbors < MAX_NEIGHBORS) // 0 < 64
                        {
                            //cout << nh[i].numNeighbors << endl; //-- 0,1,2,3,4,5,6,7,8,9,10,11 dentro del ciclo for hasta aproximadamente 11
                            nh[j].neighborhoodList[nh[j].numNeighbors] = pgrid; // el valor de &pj se asigna nh

                            
                            nh[j].r[nh[j].numNeighbors] = r; // double r = sqrt(r2);
                            
                            ++nh[j].numNeighbors; // aumenta en una unidad hasta aproximadamente 11 dentro de este ciclo
                            //print("nh[i].numNeighbors");
                            //print(nh[i].numNeighbors);
                            
                        }
                    }
                }
            }

            genericParticles1[j].densidad = dens;
           // print("genericParticles1[i].densidad");
            //print(genericParticles1[i].densidad);

            genericParticles1[j].densidad_v = dens_proj;
            //print("genericParticles1[i].densidad_v");
            //print(genericParticles1[i].densidad_v);
            
            genericParticles1[j].presion = STIFFNESS * (dens - genericParticles1[j].masa * REST_DENSITY);
            //print("genericParticles1[i].presion");
            //print(genericParticles1[i].presion);
            
            genericParticles1[j].presion_v = STIFF_APPROX * dens_proj;
           // print("genericParticles1[i].presion_v");
            //print(genericParticles1[i].presion_v);
            
            
          //print("--------------FIN CICLO INTERNO FOR PRESURESTEP--------------"); // revisado

          }
          //print("--------------FIN ciclo GENERAL PRESSURESTEP--------------");

          //print("--------------INICIO ciclo PROJECT--------------");
          // Project --------------------------------------------------
          for (int j = 0; j < genericParticles1.length; j++) ///////////////////aQUI--------------------
          {
           // print("--------------INICIO ciclo PROJECT INTERNO--------------");
              Vector2 xx = Vector2(genericParticles1[j].position.dx, genericParticles1[j].position.dy); // guarda posicion de particula evaluada
              //print("xx[0]");
              //print(xx[0]);
              //print("xx[1]");
              //print(xx[1]);

              // static vector<Neighborhood> nh(numParticles);
              for (int k = 0; k < nh[j].numNeighbors; k++) // para cada uno de los vecinos de la particula de la coleccion
              {
                  //GenericParticle pj = nh[i].neighborhoodList[j]; //la variable pj de tipo particula tomara el valor del vecino j de la coleecion de vecino de i
                  double r = nh[j].r[k]; // variable vector r almacena la posicion correspoindiente a j en el rango declarado dentro de la estructura Neighborhood correspondiente a nh r(MAX_NEIGHBORS)
                  //print("r--------");
                  //print(r);
                  
                  Offset dx_0 = nh[j].neighborhoodList[k].position - genericParticles1[j].position; // distancia entre particula i y particula vecina j // offset
                  Vector2 dx = new Vector2(dx_0.dx, dx_0.dy); // distancia entre particula i y particula vecina j // vector
                  //print("dx--------");
                  //print(dx);


                  double a = 1.0 - r / H;
                  //print("a--------");
                  //print(a);
                  
                 
                  double d = DT2 * ((genericParticles1[j].presion_v + nh[j].neighborhoodList[j].presion_v) * a * a * a * KERN_NORM + (genericParticles1[j].presion + nh[j].neighborhoodList[k].presion) * a * a * KERN) / 2.0;
                  //print("d--------");
                  //print(d);
                  // relaxation
                  // double m;  // variable de la clase Particle //  masa
                  xx -= (dx * d) / (genericParticles1[j].masa * r );
                  //print("xx--------");
                  //print(xx);

                 
                  if (genericParticles1[j].masa == nh[j].neighborhoodList[k].masa){
                      xx += dx * ((SURFACE_TENSION / genericParticles1[j].masa) * nh[j].neighborhoodList[k].masa * a * a * KERN) ;
                      //print("xx--------");
                      //print(xx);
                    }
             
                  Offset dv_offset = genericParticles1[j].velocidad - nh[j].neighborhoodList[k].velocidad;
                  
                  Vector2 dv = new Vector2(dv_offset.dx, dv_offset.dy);
                  //print("dv--------");
                  //print(dv);
                  double u = dv.dot(dx); // producto escalar de vector2d dv con dx
                  //print("u--------");
                  //print(u);


                  if (u > 0)
                  {
                      u /= r;
                      //print("u--------");
                      //print(u);
                      double a = 1 - r / H;
                      //print("a--------");
                      //print(a);
                      double I = 0.5 * DT * a * (LINEAR_VISC * u + QUAD_VISC * u * u);
                      //print("I--------");
                      //print(I);
                      xx -= dx * (DT * I);
                     // print("xx--------");
                      //print(xx);
                  }
                  //print("--------------FIN ciclo PROJECT INTERNO--------------");
              }
              //static vector<Vector2d> xprojected(numParticles); // variable global
              xprojected[j] = xx; // relaxation
              //print("xprojected[i]--------");
              //print(xprojected[i]);
          }
         // print("--------------FIN ciclo PROJECT--------------"); // REVISADO
          
         
         // print("--------------INICIO ciclo CORRECT--------------");
          for (int j = 0; j < genericParticles1.length; j++) // para cada particula 
              {
               // print("--------------INICIO ciclo CORRECT INTERNO--------------");
                //auto& p = particles[i];// dada una particula de la coleccion matriz particulas asignar variable p
                Offset relax = Offset(xprojected[j][0],xprojected[j][1]);
                  //print("relax[i]--------");
                  //print(relax);

                genericParticles1[j].position = relax; // posicion de la particula igual a xprojected (relaxation) calculado en funcion project
                genericParticles1[j].velocidad = (genericParticles1[j].position - xlast[j]) / DT; // velocidad igual a la posicion menos posicion anterior dividido entre el tiempo
                 // print("genericParticles1[i].velocidad--------");
                 // print(genericParticles1[i].velocidad);
                                
               // print("--------------FIN ciclo CORRECT INTERNO--------------");
              }
         // print("--------------FIN ciclo CORRECT--------------"); // REVISADO
          
          
         // print("--------------INICIO ciclo GRIDINSERT 2--------------");
         
          grid.clear();
            
           Iterable.generate(NUM_CELLS).forEach((l) { // inicializacion de particulas  
                    grid.add( // inicializacion de valores no inicializados en la calse Node
                      new GenericParticle
                        ( position: Offset(0.0, 0.0), 
                          velocidad: Offset(0.0, 0.0),
                          //n1:GenericParticle( position: Offset(0.0, 0.0), velocidad: Offset(0.0, 0.0)),
                          )
                      );
                    } 
                  );
         
          for (int j = 0 ,k = MAX_PARTICLES; j < genericParticles1.length; j++,k++){

         // print("--------------INICIO ciclo interno GRIDINSERT--------------");
            
                       
            int indice = k-MAX_PARTICLES;  
    
            double px = (genericParticles1[j].position.dx / CELL_SIZE)+0.001;
 
           
            int xind = px.ceil();
            //int xind = xind1.ceil();
            //print("xind---------$xind");
           

            double py = (genericParticles1[j].position.dy / CELL_SIZE)+0.001;

            //int yind = py.floor();
            int yind = py.ceil();
            //int yind = yind1.toceil();
            //print("yind---------$yind");

            xind = max(1,(min(GRID_WIDTH - 2, xind)));
            yind = max(1,(min(GRID_HEIGHT - 2, yind)));
            //print("xindMax---------$xind");
            //print("yindMax---------$yind");
            
            //print(xind.toDouble()); //**--
            //print(yind.toDouble()); //**--
            //print((xind+yind*GRID_WIDTH).toDouble()); // 22671 -- 22672 -- 22671 -- 22672 **--
            //print("hola que hace");

            
            

         
            genericParticles1[j].n1 = grid[xind+yind*GRID_WIDTH].n1; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
            //print(genericParticles1[i].n.nulidad);
            // if (genericParticles1[i].n1 == null) {
            //   print(" grid null");
              
            // } else {
            //   print(" grid no null");
            // }
           // print(xind+yind*GRID_WIDTH);
            
            grid[xind+yind*GRID_WIDTH].n1 = genericParticles1[j];
            
            //genericParticles1[i].n1 = grid[xind+yind*GRID_WIDTH].n1; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
           // print(xind+yind*GRID_WIDTH);
            

            
            gridIndices[indice] = Vector2(xind.toDouble(), yind.toDouble()); //va
           // print("gridIndices---------");
           // print(gridIndices);

            //print("--------------fin ciclo interno GRIDINSERT--------------");

          }
         // print("--------------FIN ciclo GRIDINSERT--------------"); // revisado



         // print("--------------INICIO ciclo ENFORCEBOUNDARY--------------");

          for (int j = 0; j < genericParticles1.length; j++)
          { // para cada particula
              for (int k = 0; k < boundaries.length; k++) // static vector<Vector3d> boundaries = vector<Vector3d>(); // variable global
              {//var boundaries = List<Vector3>.filled(MAX_PARTICLES, Vector3(0.0,0.0,0.0)); // lista con 25 elementos tipo vector3 inicializados en 0

               // print("--------------INICIO ciclo interno boundaries--------------");
                double d = genericParticles1[j].position.dx * boundaries[k][0] + genericParticles1[j].position.dy * boundaries[k][1] - boundaries[k][2];
                // print("p.x(0)");
                // print( genericParticles1[i].position.dx);
                // print("b(0)");
                // print(boundaries[i][0]);
                // print("p.x(1)");
                // print(genericParticles1[i].position.dy);
                // print("b(1)");
                // print(boundaries[i][1]);
                // print("b(2)");
                // print(boundaries[i][2]);

                
                //print("d------------");
               // print(d);
  
                  if ((d = max(0.0, d)) < PARTICLE_RADIUS)
                    {
                      Offset boundarieAux = Offset(boundaries[k][0] / DT, boundaries[k][1] / DT);
                      genericParticles1[j].velocidad += boundarieAux *(PARTICLE_RADIUS - d);
                      //print("genericParticles1[i].velocidad");
                      //print(genericParticles1[i].velocidad);
                    }
                    //print("--------------fin ciclo interno boundaries--------------");
              }
              
        }
        //print("--------------FIN ciclo ENFORCEBOUNDARY--------------");
        
        //print("--------------FIN -");



      }



}



//********************************************************************************************************************* */

//********************************************************************************************************************* */

//********************************************************************************************************************* */

//********************************************************************************************************************* */

//*******************************************INICIO CICLO PRINCIPAL******************************************************* */
    animationController = new AnimationController(
        vsync: this, duration: new Duration(seconds: 10))
      ..addListener(() {

       // print("-----------------------primer iteracion----------------------------");
         
  
  //print("--------------REnder-------------------------");
  for (int i = 0; i < nodeList.length; i++) 
  {
     // ACTUALIZACION POSICION
     

    nodeList[i].position = genericParticles1[i].position;
   // double colorear2 = 255 / i + 1;
    //int colorear = colorear2.toInt();
   //nodeList[i].notePaint.color=Color.fromARGB(255,255*i, 0, 150); // color dinamico segun fuerza
    
    //print("------------------------");
    //print(nodeList[i].position.dx);
    //print(nodeList[i].position.dy);    
  }


  move();

    }
      
    )
      ..repeat();
  }




  @override
  Widget build(BuildContext context) {
    return new Container(
      child: new AnimatedBuilder(
        animation: animationController,
        builder: (context, child) => new CustomPaint(
              size: widget.screenSize,
              painter: new _DemoPainter(widget.screenSize, nodeList),
            ),
      ),
    );
  }
}


class _DemoPainter extends CustomPainter {
  final List<Node> nodeList;
  final Size screenSize;
  var counter = 0;

  _DemoPainter(this.screenSize, this.nodeList);

  @override
  void paint(Canvas canvas, Size size) {
    for (var node in nodeList) {
      node.display(canvas);
    }
  }

  @override
  bool shouldRepaint(_DemoPainter oldDelegate) => true;
}


class Node {
      int id;
      Size screenSize;
      double size;
      Random random;
      Paint notePaint, linePaint;
      
      
      // position, velocity, and mass
      Offset position; // x
      Offset velocidad; // v
      double masa; // m
      // pressure, density, and their variations
      double densidad;
      double densidad_v;
      double presion;
      double presion_v;
      Offset viscosidad;
    
      
      int numNeighbors;
      bool nulidad;
      //GenericParticle n;

  Node(
      {
      @required this.id,
      @required this.screenSize,
      @required this.size,//Tamaño del punto 
      @required this.position,
      @required this.velocidad,
      //@required this.n,
      
      
      this.masa = 1.0,
      this.presion = 0.0,
      this.presion_v = 0.0,
      this.densidad = 0.0,
      this.densidad_v = 0.0,
      
      this.nulidad = true,
      
      }) {
   
    random = new Random(); 
   

    notePaint = new Paint()
      ..color = Colors.blue;

    
    linePaint = new Paint()
      ..color = Colors.blueAccent
      ..strokeWidth = 0.5
      ..style = PaintingStyle.stroke;
  }

 
   void display(Canvas canvas) {
     canvas.drawCircle(position, size, notePaint);
    }

  bool operator ==(o) => o is Node && o.id == id;
  int get hashCode => id;
}


class Neighborhood {
  
  
  
        // position, velocity, and mass
        Offset position;      // x
        Offset velocidad;     // v
        double masa;          // m
        // pressure, density, and their variations
        double densidad;      // d
        double densidad_v;    // dv
        double presion;       // p
        double presion_v;     // pv

        List<GenericParticle>neighborhoodList; // Particles      
        int numNeighbors;
        List<double> r;

  

 Neighborhood(
      {
      
      
        @required this.neighborhoodList ,
        @required this.position,
        @required this.velocidad,
        @required this.r,
                
        this.masa = 1.0,
        this.presion = 0.0,
        this.presion_v = 0.0,
        this.densidad = 0.0,
        this.densidad_v = 0.0,
        

       
        this.numNeighbors = 0,
        

      }) {  }

}

class GenericParticle { // grid
  
        // position, velocity, and mass
        Offset position;      // x
        Offset velocidad;     // v
        double masa;          // m
        // pressure, density, and their variations
        double densidad;      // d
        double densidad_v;    // dv
        double presion;       // p
        double presion_v;     // pv
              
        int numNeighbors;
        bool nulidad;

        GenericParticle n1;
        

        
      GenericParticle( //
        {

        @required this.position,
        @required this.velocidad,
        this.n1,
       
                        
        this.masa = 1.0,
        this.presion = 0.0,
        this.presion_v = 0.0,
        this.densidad = 0.0,
        this.densidad_v = 0.0,
        this.numNeighbors = 0,
        this.nulidad = false
        
        }) 
          { } // para inicializar variables o modificarlas
          //void move(){} // funciones de la clase ejemplo: move
    }


// class GenericParticle2 { // grid
  
//         // position, velocity, and mass
//         Offset position;      // x
//         Offset velocidad;     // v
//         double masa;          // m
//         // pressure, density, and their variations
//         double densidad;      // d
//         double densidad_v;    // dv
//         double presion;       // p
//         double presion_v;     // pv
              
//         int numNeighbors;
//         bool nulidad;

        
        
//       GenericParticle2( //
//         {

//         @required this.position,
//         @required this.velocidad,
                               
//         this.masa = 1.0,
//         this.presion = 0.0,
//         this.presion_v = 0.0,
//         this.densidad = 0.0,
//         this.densidad_v = 0.0,
//         this.numNeighbors = 0,
//         this.nulidad = false
        
//         }) 
//           { } // para inicializar variables o modificarlas
//           //void move(){} // funciones de la clase ejemplo: move
//     }


/*

//*********************************************************************************************************************************** */
// //import 'dart:ffi';
// //import 'dart:ffi';
// import 'dart:ffi';
// import 'dart:math';
// import 'package:flutter/foundation.dart';
// import 'package:flutter/widgets.dart';
// import 'package:flutter/animation.dart';
// import 'package:flutter/material.dart';
// import 'package:vector_math/vector_math.dart' hide Colors; // Colors esta definida tanto en libreria material como en Vector

// import 'package:sensors_plus/sensors_plus.dart';

// import 'package:flutter/services.dart'; // para evitar rotacion entre otros

// // SPH fluid
// main() {
  
//   WidgetsFlutterBinding.ensureInitialized();// para evitar que gire la pantalla agregar libreria services
//   SystemChrome.setPreferredOrientations([DeviceOrientation.portraitUp])// para evitar que gire la pantalla agregar libreria services
//     .then((_) {// para evitar que gire la pantalla agregar libreria services
//       runApp(new MaterialApp(home: new DemoPage()));
//       });

// }

// class DemoPage extends StatelessWidget {
//   @override
//   Widget build(BuildContext context) {
//     assert(debugCheckHasMediaQuery(context));
//     return new Scaffold(
//       body: new DemoBody(
//         screenSize: MediaQuery.of(context).size,
//       ),
//     );
//   }
// }

// class DemoBody extends StatefulWidget {
//   final Size screenSize;

//   DemoBody({Key key, @required this.screenSize}) : super(key: key);

//   @override
//   State<StatefulWidget> createState() {
//     return new _DemoBodyState();
//   }
// }

// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// // class _DemoBodyState extends State<DemoBody> with TickerProviderStateMixin {
// //   AnimationController animationController;
  
  

  
// //   //final numNodes = 150;
// //   //final numNodes = 100; //DATO ORIGINAL

// //   double gyroX = 0;
// //   double gyroY = 0;
// //   double gyroZ = 0;
// //   //Pointer<Float> _outBuf;

// //   //VARIABLES PCISPH globales---------------------------------------
// //   //https://pub.dev/packages/vector_math
// //   Vector3 vectordart = new Vector3(1,2,3); // ejemplo vector3
// //   List<Vector3> boundaries = [];

// //   //---------------------------------------------------------------
    
// //   @override
// //   void initState() {
// //     super.initState();
// //    // Para interaccion con girospio, acelerometro, // ESTO SOLO FUNCIONA CUANDO SE SELECCIONA EL EMULADOR pixel 3 XL API 29
// //       gyroscopeEvents.listen((GyroscopeEvent event) { // agregar libreria sensor_plus.dart
// //       setState(() {
// //         // gyroX = ((event.x * 100).round() / 100).clamp(-1.0, 1.0) * -1;
// //         // gyroY = ((event.y * 100).round() / 100).clamp(-1.0, 1.0);
// //         // gyroZ = ((event.y * 100).round() / 100).clamp(-1.0, 1.0);
// //         gyroX = event.x;
// //         gyroY = event.y;
// //         gyroZ = event.z;
// //       });
// //     });
    
// //     // INICIAZLIZACION Y CREACION DE VARIALBES 
    
// //     double REST_DENS = 1000.0; // densidad en reposo
// //     double GAS_CONST = 2000.0; // const for equation of state
    
    
// //     //double H = 16.0; // kernel radius DATO ORIGINAL
// //     //double HSQ = H * H; // radius^2 for optimization
// //     double MASS = 65.0; // assume all particles have the same mass
// //     double VISC = 250.0; // viscosity constant
// //      // integration timestep

// // // smoothing kernels defined in Müller and their gradients
    
// // // simulation parameters
   
// //     double BOUND_DAMPING = -0.5; // amortiguacion 
// //     Offset G = Offset(0.0, -9.81);

// // //VARIABLES NUEVAS PCISPH -------------------------------------------------------
// //     double PARTICLE_RADIUS = 0.03;
// //     double H = 6.0 * PARTICLE_RADIUS; // kernel radius
// //     double EPS = 0.0000001; // boundary epsilon
// //     double VIEW_WIDTH = 20.0;
// //     double VIEW_HEIGHT = widget.screenSize.height * VIEW_WIDTH / widget.screenSize.width;
// //     int SOLVER_STEPS = 10;
// //     int fps = 40;
// //     double DT = ((1.0 / fps) / SOLVER_STEPS);

// //     boundaries.add(Vector3(1, 0, 0));
// //     boundaries.add(Vector3(1, 1, 0));
// //     boundaries.add(Vector3(-1, 0, -VIEW_WIDTH));
// //     boundaries.add(Vector3(1, 0, -VIEW_HEIGHT));

// //     Vector2 start = new Vector2(0.25*VIEW_WIDTH, 0.95*VIEW_HEIGHT);
// //     double spacing = PARTICLE_RADIUS;
    
// //     int MAX_PARTICLES = 5 * 5;
// //     int numNodes = MAX_PARTICLES; // numParticles
// //     var xlast = List<Offset>.filled(numNodes, Offset(0.0,0.0)); // lista con 5 elementos tipo offset inicializado en 0
// //     var gridIndices = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector inicializados en 0
// //     //Vector2 gridIndices1 = new Vector2(0.0, 0.0);
// //     final int MAX_NEIGHBORS = 64;
// //     double CELL_SIZE = H;

// //     int GRID_WIDTH = (VIEW_WIDTH / CELL_SIZE).toInt();
// //     int GRID_HEIGHT = (VIEW_HEIGHT / CELL_SIZE).toInt();

// //     int NUM_CELLS = GRID_WIDTH * GRID_HEIGHT;

// //     double EPS2 = EPS * EPS;

// //     double KERN = 20.0 / (2.0 * 5.0 * H * H);
// //     double KERN_NORM = 30.0 / (2.0 * 5.0 * H * H); // LVSTODO: better naming
// //     double STIFFNESS = 0.08;
// //     double STIFF_APPROX = 0.1;
// //     double REST_DENSITY = 45.0;
// //     double DT2 = DT * DT;
// //     double SURFACE_TENSION = 0.0001;

// //     //-------------------------------------------------FIN VARIABLES PCISPH
// //     // VARIABLES DEPENDIENTES
// //     double POLY6 = 315.0 / (65.0 * 3.1416 * pow(H, 9.0)); // El núcleo poly6 también se conoce como núcleo polinomial de sexto grado. 
// //     double SPIKY_GRAD = -45.0 / (3.1416 * pow(H, 6.0)); // El gradiente del núcleo spiky se usa para calcular la fuerza de presión
// //     double VISC_LAP = 45.0 / (3.1416 * pow(H, 6.0)); // El Laplaciano de este núcleo (viscosity) se usa para calcular la fuerza de viscosidad 

// ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// //ORIGINAL//

// class _DemoBodyState extends State<DemoBody> with TickerProviderStateMixin {
//   AnimationController animationController;
//   final nodeList = <Node>[];
//   final numNodes = 2*2;
  
//   //   final nodeList = <Node>[]; // Particles
//   //final sub_nh = <Node>[]; // Sub Particulas para integrar a lista neighborhoodList dentro de Neighborhood nh
//   final nh = <Neighborhood>[]; // Neighbors
//   final grid = <GenericParticle>[]; // Particles

//   double gyroX = 0;
//   double gyroY = 0;
//   double gyroZ = 0;

//   @override
//   void initState() {
//     super.initState();

    
//       // Para interaccion con girospio, acelerometro, // ESTO SOLO FUNCIONA CUANDO SE SELECCIONA EL EMULADOR pixel 3 XL API 29
//       gyroscopeEvents.listen((GyroscopeEvent event) { // agregar libreria sensor_plus.dart
//       setState(() {
//         // gyroX = ((event.x * 100).round() / 100).clamp(-1.0, 1.0) * -1;
//         // gyroY = ((event.y * 100).round() / 100).clamp(-1.0, 1.0);
//         // gyroZ = ((event.y * 100).round() / 100).clamp(-1.0, 1.0);
//         gyroX = event.x;
//         gyroY = event.y;
//         gyroZ = event.z;
//       });
//     });
    
     
    
//     double REST_DENS = 1000.0; // densidad en reposo
//     double GAS_CONST = 2000.0; // const for equation of state
//     //double H = 3; // kernel radius
    
//     //double HSQ = H * H; // radius^2 for optimization
//     double MASS = 65.0; // assume all particles have the same mass
//     double VISC = 250.0; // viscosity constant
//     //double DT = 0.00080; // integration timestep

// // smoothing kernels defined in Müller and their gradients
//     //double POLY6 = 315.0 / (65.0 * 3.1416 * pow(H, 9.0)); // El núcleo poly6 también se conoce como núcleo polinomial de sexto grado. 
//    // double SPIKY_GRAD = -45.0 / (3.1416 * pow(H, 6.0)); // El gradiente del núcleo spiky se usa para calcular la fuerza de presión
//    // double VISC_LAP = 45.0 / (3.1416 * pow(H, 6.0)); // El Laplaciano de este núcleo (viscosity) se usa para calcular la fuerza de viscosidad 

// // simulation parameters
//     //double EPS = H; // boundary epsilon
//     double BOUND_DAMPING = -0.5; // amortiguacion 
//     //Offset G = Offset(0.0, 12000 * 9.8);

// // Variables pcisph
//     double PARTICLE_RADIUS = 0.03;
//     double H = 6.0 * PARTICLE_RADIUS; // kernel radius
//     double HSQ = H * H; // radius^2 for optimization
//     double CELL_SIZE = H;
//     double VIEW_WIDTH = 20.0;
//     double VIEW_HEIGHT = widget.screenSize.height.toInt() * VIEW_WIDTH / widget.screenSize.width.toInt();
//     int GRID_WIDTH = (VIEW_WIDTH / CELL_SIZE).toInt();
//     int GRID_HEIGHT = (VIEW_HEIGHT / CELL_SIZE).toInt();
//     int NUM_CELLS = GRID_WIDTH * GRID_HEIGHT;
//     double spacing = PARTICLE_RADIUS ;
//     final int MAX_NEIGHBORS = 64;

//     double POLY6 = 315.0 / (65.0 * 3.1416 * pow(H, 9.0)); // El núcleo poly6 también se conoce como núcleo polinomial de sexto grado. 
//     int SOLVER_STEPS = 10;

//     int MAX_PARTICLES = numNodes;
//     var gridIndices = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector inicializados en 0
//     var xlast = List<Offset>.filled(numNodes, Offset(0.0,0.0)); // lista con 5 elementos tipo offset inicializado en 0
//     double EPS = 0.0000001;
//     double EPS2 = EPS * EPS;
//     double KERN = 20.0 / (2.0 * 5.0 * H * H);
//     double KERN_NORM = 30.0 / (2.0 * 5.0 * H * H);
//     double STIFFNESS = 0.08;
//     double REST_DENSITY = 45.0;
//     double STIFF_APPROX = 0.1;
//     int fps = 40;
//     double DT = ((1.0 / fps) / SOLVER_STEPS);
//     Offset g = Offset(0.0, -9.81);
//     double DT2 = DT * DT;
//     double SURFACE_TENSION = 0.0001;
//     double LINEAR_VISC = 0.25;
//     double QUAD_VISC = 0.5;
//     var xprojected = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector2 inicializados en 0
//     //var boundaries = List<Vector3>.filled(MAX_PARTICLES, Vector3(0.0,0.0,0.0)); // lista con 25 elementos tipo vector3 inicializados en 0
//     List<Vector3> boundaries = [];
//     boundaries.add(Vector3(1, 0, 0));
//     boundaries.add(Vector3(1, 1, 0));
//     boundaries.add(Vector3(-1, 0, -VIEW_WIDTH));
//     boundaries.add(Vector3(1, 0, -VIEW_HEIGHT));
//     //print(widget.screenSize.width.toInt());
//     //print(widget.screenSize.height.toInt());
//     //print(0.95*VIEW_HEIGHT);
    



// //COMENTAR ESTA PARTE ORIGINAL
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ///

// //----------------------------------------------------------------------------------
    
//     //var listaxy = List<Vector2>.filled(numNodes, Vector2(0.0,0.0)); // lista con 5 elementos tipo offset inicializado en  
//     var listaxy = [];
//     int num = sqrt(numNodes).toInt();
//     //Vector2 start = Vector2(0.25 * VIEW_WIDTH, 0.95 * VIEW_HEIGHT); // start se refiere a variable tipo Vector2d, creada por el programador
//     //double x0 = start.x; // para intrar a los valores internos de un Vector2 se utiliza x e y
    
//     double x = 0.25 * VIEW_WIDTH;
//     double y = 0.95 * VIEW_HEIGHT;
//     //print(x0);
//     for (double i = 0, y = 0.95 * VIEW_HEIGHT; i < num; i++, y -= 2.0 * PARTICLE_RADIUS + spacing) // recorre todas las particulas para acomodarlas en rompimiento de presa.
//     {
//       //print("ciclo principal");
//       //print(i);
//       //print(start);
//         for (int j = 0; j < num; j++) // aqui se actuliza valor y, dentro no lo reconoce
//         {
//             //print(j);
//             //print(y);
//             listaxy.add([x,y]);
//            // print("listaxy[j]");
//            // print(listaxy[j.toInt()]);
//             //listaxy.add(start); // a cada particula le asigna el vector start
            
//             x += 2.0 * PARTICLE_RADIUS + spacing; // actualiza valor de primera posicion del vector start sumando esta operacion 
//             // print("segundo ciclo");
//             //print(start);
//             //cout << j << endl;
//         }
//         x = 0.25 * VIEW_WIDTH; // resetea posicion x
//         //print(start.y);
//        // print("listaxy[1]");
//        // print(listaxy[1]);
//        // y -= 2.0 * PARTICLE_RADIUS + spacing;// baja la posicion y // NO RECONOCE ESTE CAMBIO, POR ESO SE ENVIO AL CONTROL DE FOR
//         //print("y");
//         //print(y);

//     }
    
//     //print(listaxy);

    
//     // INICIALIZACION PARTICULAS principales---------------------------------------------------------------------------------------------------------

//     Iterable.generate(numNodes).forEach((i) { // inicializacion de particulas
      
//       double valx = (listaxy[i][0]); // variable para posicion inicial en x
//       double valy = (listaxy[i][1]); // variable para posicion inicial en y

//        nodeList.add( // inicializacion de valores no inicializados en la calse Node
//         new Node(
//           id: i, 
//           screenSize: widget.screenSize, 
//           size: 2.5 * PARTICLE_RADIUS * widget.screenSize.width / VIEW_WIDTH, // tamaño de la particula
//           position: Offset(valx, valy),
//           velocidad: Offset(0.0, 0.0),
//           n:GenericParticle( 
//             position: Offset(0.0, 0.0), 
//             velocidad: Offset(0.0, 0.0),
//             n:GenericParticle2( 
//               position: Offset(0.0, 0.0), 
//               velocidad: Offset(0.0, 0.0),)),
//           )
//         );
//       } 
//     );
// // INICIALIZACION PARTICULAS fin ---------------------------------------------------------------------------------------------------------

// // INICIALIZACION PARTICULAS auxiliares ---------------------------------------------------------------------------------------------------------


//  Iterable.generate(NUM_CELLS).forEach((i) { // inicializacion de particulas  
//       grid.add( // inicializacion de valores no inicializados en la calse Node
//         new GenericParticle
//           ( position: Offset(0.0, 0.0), 
//             velocidad: Offset(0.0, 0.0),
//             n:GenericParticle2( position: Offset(0.0, 0.0), velocidad: Offset(0.0, 0.0)),
//             )
//         );
//       } 
//     );

// // INICIALIZACION vecinos numNeighbors---------------------------------------------------------------------------------------------------------

//     Iterable.generate(numNodes).forEach((i) { // inicializacion de particulas
      
//       nh.add( // inicializacion de valores no inicializados en la calse Node
//         new Neighborhood(
//                     position: Offset(0.0, 0.0),
//                     velocidad: Offset(0.0, 0.0),
//                     r: List<double>.filled(MAX_NEIGHBORS, 0.0),
//                     neighborhoodList: List<GenericParticle>.filled(MAX_NEIGHBORS, // 64 vecinos tipo ParticlesNeighborhood // neighborhoodList es una lista a la que se le asigna otra lista de varios elementos ya inicializados          
//                             GenericParticle( 
//                                             position: Offset(0.0, 0.0),
//                                             velocidad: Offset(0.0, 0.0),
//                                             n:GenericParticle2( 
//                                                                 position: Offset(0.0, 0.0), 
//                                                                 velocidad: Offset(0.0, 0.0)
//                                                                 ),
//                                             )
//                                                         )
//                          ), 
//           //
//           //
//           //
//           //)
//         );
//       } 
//     );
// // INICIALIZACION vecinos fin ---------------------------------------------------------------------------------------------------------

// // ---------------------------------------------------------------- GRIDINSERT ---------------------------------------------------------------------------------------------------------


//           for (int i=0 ,j = MAX_PARTICLES; i < nodeList.length; i++,j++){

            
//             int indice = j-MAX_PARTICLES;  
//             //print(indice);// para el caso de 5 * 5 es una numeracion de 0 a 24 (25 particulas en total)
//             //var p = nodeList[i]; // toma una particula
//             double px = nodeList[i].position.dx / CELL_SIZE;
//             /* double d = 20.5; // ejemplo
//             int i = d.toInt(); // i = 20
//             int i = d.round(); // i = 21
//             int i = d.ceil();  // i = 21
//             int i = d.floor(); // i = 20
//             */
//             int xind = px.toInt();
//             //print("--xind--");
//             //print(xind);

//             //print(xind);
//             // print (p.position.dx);
//             // print (CELL_SIZE);
//             // print (xind);
//             // print ("SALTO");
//             // print ("SALTO");

//             double py = nodeList[i].position.dy / CELL_SIZE;

//             //int yind = py.floor();
//              int yind = py.toInt();
//             //  print("analisis yind");
//             //print(CELL_SIZE);
//            //print(nodeList[i].position.dy);
//            // print(py);
//             //  print(yind);
//             // print(yind);
//             //  print (p.position.dy);
//             //  print (CELL_SIZE);
//             //  print (yind);
//             //  print ("SALTO");
//             // print ("SALTO");

//             /* Flutter Dart Find Minimum Number Value Between Two Numbers           
//               int A = 120;
//               int B = 110;
//               int C;
//               int D;

//               // Finding Minimum Value.
//               C = min(A, B);
//               D = max(A, B);

//               // Finding Minimum Value.
//               C = min(A, B);
//               D = max(A, B);            
//             */
//             xind = max(1,(min(GRID_WIDTH - 2, xind)));
//             yind = max(1,(min(GRID_HEIGHT - 2, yind)));

//             //print("yind");
//             //print(yind);

//             //print("--NUMERO GUIA--");
//             //print(xind + yind * GRID_WIDTH);
            
//             //nodeList[i].n = grid[xind+yind*GRID_WIDTH]; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
           
//             // nodeList[i].n = grid[xind+yind*GRID_WIDTH];

//             // grid[xind + yind * GRID_WIDTH].position = nodeList[i].position;
//             // grid[xind + yind * GRID_WIDTH].velocidad = nodeList[i].velocidad;
//             // grid[xind + yind * GRID_WIDTH].masa = nodeList[i].masa;
//             // grid[xind + yind * GRID_WIDTH].densidad = nodeList[i].densidad;
//             // grid[xind + yind * GRID_WIDTH].densidad_v = nodeList[i].densidad_v;
//             // grid[xind + yind * GRID_WIDTH].presion = nodeList[i].presion;
//             // grid[xind + yind * GRID_WIDTH].presion_v = nodeList[i].presion_v;
//             // grid[xind + yind * GRID_WIDTH].nulidad = true; // default value false
            
            
//             //grid[xind + yind * GRID_WIDTH].n = nodeList[i].n; // guardar dentro de var n la var n de nodelist que es ella misma(grid)

//              // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
            
//             gridIndices[indice] = Vector2(xind.toDouble(), yind.toDouble()); //var gridIndices = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector inicializados en 0

//           }
//           //print("*******************gridIndices***********************");
//           print(gridIndices);
//           //print(gridIndices.length);

//     //ComputeDensityPressure
//     //Vector2 positi = new Vector2(1.0,1.0);
    

//     animationController = new AnimationController(
//         vsync: this, duration: new Duration(seconds: 10))
//       ..addListener(() {

//         print("-----------------------primer iteracion----------------------------");
        
//          for (int i = 0; i < SOLVER_STEPS; i++) {


// //------------------------------// ApplyExternalForces
//           for (var p in nodeList) {
//             p.velocidad += g * DT;
//             //print("-------------p.velocidad---------------");
//             //print("-------------p.velocidad---------------");
//             //print(DT); // 0.0025
//             //print(g); // Offset(0.0, -9.8)
//             //print(p.velocidad.dy); //-0.024525

//           }

          
//  //------------------------------// Integrate
//           for (int i = 0; i < nodeList.length; i++){
//             //var p = nodeList[i]; // toma una particula
//             xlast[i] = nodeList[i].position; //guarda posicion de particula actual(i)
//             nodeList[i].position += nodeList[i].velocidad * DT ; //  suma y actualiza posicion debida a la velocidad y tiempo 
//             //print("nodeList[i].position");
//             //print(nodeList[i].position);
//           }

//           //print("--------------fin primer ciclo integrate--------------");

// //------------------------------// GridInsert

//           print("--------------INICIO ciclo GRIDINSERT--------------");
//           for (int i=0 ,j = MAX_PARTICLES; i < nodeList.length; i++,j++){

            
//             int indice = j-MAX_PARTICLES;  
//             //print(indice);// para el caso de 5 * 5 es una numeracion de 0 a 24 (25 particulas en total)
//             //var p = nodeList[i]; // toma una particula
//             double px = nodeList[i].position.dx / CELL_SIZE;
//             /* double d = 20.5; // ejemplo
//             int i = d.toInt(); // i = 20
//             int i = d.round(); // i = 21
//             int i = d.ceil();  // i = 21
//             int i = d.floor(); // i = 20
//             */
//             int xind = px.toInt();
//             //print("--xind--");
//             //print(xind);

//             //print(xind);
//             // print (p.position.dx);
//             // print (CELL_SIZE);
//             // print (xind);
//             // print ("SALTO");
//             // print ("SALTO");

//             double py = nodeList[i].position.dy / CELL_SIZE;

//             //int yind = py.floor();
//             int yind = py.toInt();
//             //  print("analisis yind");
//             //print(CELL_SIZE);
//            //print(nodeList[i].position.dy);
//             //print(py);
//             //  print(yind);
//             // print(yind);
//             //  print (p.position.dy);
//             //  print (CELL_SIZE);
//             //  print (yind);
//             //  print ("SALTO");
//             // print ("SALTO");

//             /* Flutter Dart Find Minimum Number Value Between Two Numbers           
//               int A = 120;
//               int B = 110;
//               int C;
//               int D;

//               // Finding Minimum Value.
//               C = min(A, B);
//               D = max(A, B);

//               // Finding Minimum Value.
//               C = min(A, B);
//               D = max(A, B);            
//             */
//             xind = max(1,(min(GRID_WIDTH - 2, xind)));
//             yind = max(1,(min(GRID_HEIGHT - 2, yind)));

//             //print("yind");
//             //print(yind);

//             //print("--NUMERO GUIA--");
//             //print("xind + yind * GRID_WIDTH");
//             //print(xind + yind * GRID_WIDTH);
            
//             nodeList[i].n = grid[xind+yind*GRID_WIDTH]; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
//             //print("ANTES-----------------------------nodeList[i].nulidad");
//             print(nodeList[i].n.nulidad); //FALSE
//             //nodeList[i].n = grid[xind+yind*GRID_WIDTH];

//             grid[xind + yind * GRID_WIDTH].position = nodeList[i].position;
//             grid[xind + yind * GRID_WIDTH].velocidad = nodeList[i].velocidad;
//             grid[xind + yind * GRID_WIDTH].masa = nodeList[i].masa;
//             grid[xind + yind * GRID_WIDTH].densidad = nodeList[i].densidad;
//             grid[xind + yind * GRID_WIDTH].densidad_v = nodeList[i].densidad_v;
//             grid[xind + yind * GRID_WIDTH].presion = nodeList[i].presion;
//             grid[xind + yind * GRID_WIDTH].presion_v = nodeList[i].presion_v;
//             grid[xind + yind * GRID_WIDTH].nulidad = nodeList[i].nulidad; // default value false
            
//             //print("DESPUES-----------------------------nodeList[i].nulidad");
//             //print(nodeList[i].nulidad); // FALSE
            
//             //grid[xind + yind * GRID_WIDTH].n = nodeList[i].n; // guardar dentro de var n la var n de nodelist que es ella misma(grid)

//              // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
            
//             gridIndices[indice] = Vector2(xind.toDouble(), yind.toDouble()); //var gridIndices = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector inicializados en 0

//           }
//           print("--------------FIN ciclo GRIDINSERT--------------");

// //------------------------------// PressureStep
//           print("--------------INICIO ciclo PRESSURESTEP--------------");
//           for (int i = 0; i < nodeList.length; i++)
//           {
//             //var p_i = nodeList[i]; // toma una particula
//             Vector2 ind = Vector2(gridIndices[i][0],(gridIndices[i][1]) * GRID_WIDTH);
//             //nh[i].numNeighbors = 0; // revisar si es necesario

//             double dens = 0.0;
//             double dens_proj = 0.0;

            
//             for (int ii = ind[0].toInt() - 1; ii <= ind[0] + 1; ii++)
//             {
//               print("grid[ii]");
//                 //print(grid[ii]);
                
//                 for (int jj = ind[1].toInt() - GRID_WIDTH; jj <= ind[1] + GRID_WIDTH; jj += GRID_WIDTH)
//                 { //static const int GRID_WIDTH = (int)(VIEW_WIDTH / CELL_SIZE); = 111 // static const static double VIEW_WIDTH = 20.0f;// const double CELL_SIZE = H; // const static double H = 6.0f * PARTICLE_RADIUS; //
//                 print("grid[jj]");
//                //print("aqui si llega");
//                     for (GenericParticle pgrid = grid[ii+jj]; pgrid.nulidad != false; pgrid.nulidad = nodeList[i].n.nulidad) // asigna a particula nueva pgrid el valor de particula grid que antes guardo valores de las particulas generales == static vector<Particle*> grid(NUM_CELLS); // static const int NUM_CELLS = GRID_WIDTH * GRID_HEIGHT;
//                     { // para la particula ubicada en ii+jj, hasta que pgrid sea nulo, todas las particulas linkadas a esa particula
//                         // ejemplo de logica usada en este for
//                             // int grid = 11;
//                             print(ii);
//                             print(jj);
//                             print(ii+jj);
//                             print("grid[ii+jj]");
//                             print(grid[ii+jj]);
                            

//                             // int* pgrid = &grid;
//                             // cout << pgrid << endl; // x0x7ffca9c3409c
//                             // int& pj = *pgrid; // similar al caso de la variable de inicializacion de este for "Particle* pgrid = grid[ii + jj]", ya que grid es un vector de apuntadores
//                             // cout << pj << endl; // 11 // en este caso pgrid toma el  valor almacenado en grid[ii+jj]
//                             // int& pi = grid;
//                             // cout << pi << endl; //  11

//                            // Node p_j = pgrid; // & pj toma el valor almacenado en pgrid
                        
//                         // ----------------------------------------------------------------------AQUI
//                         //Offset dx_offset = p_j.position - p_i.position;
//                         Offset dx_offset = pgrid.position - nodeList[i].position;
//                         Vector2 dx = Vector2(dx_offset.dx, dx_offset.dy); // convertir offset a vector
//                         double r2 = dx[0]*dx[0] + dx[1]*dx[1] ; // suma del cuadrado de todas las entradas de la matriz.
                        
                        
//                         /*
//                             const static double EPS = 0.0000001f;
//                             const static double EPS2 = EPS * EPS;
//                             const static double PARTICLE_RADIUS = 0.03f;
//                             const static double H = 6.0f * PARTICLE_RADIUS;
//                         */
//                         if (r2 < EPS2 || r2 > H * H)
//                             continue; // termina iteracion actual y va con la siguiente
//                         double r = sqrt(r2);
//                         double a = 1.0 - r / H;
//                         /*
//                             const static double KERN = 20. / (2. * 5.0 * H * H); || global variable
//                             const static double KERN_NORM = 30. / (2. * 5.0 * H * H); // LVSTODO: better naming || global variable
//                         */
//                         //dens += p_j.masa * a * a * a * KERN;
//                         dens += grid[ii+jj].masa * a * a * a * KERN;
//                         //dens_proj += p_j.masa * a * a * a * a * KERN_NORM;
//                         dens_proj += grid[ii+jj].masa * a * a * a * a * KERN_NORM;

//                         // static vector<Neighborhood> nh(numParticles); || global variable || vector tipo Neighborhood de tamaño numParticles
//                         // const static int MAX_PARTICLES = 75 * 75; || global variable
//                         // static int numParticles = MAX_PARTICLES; || global variable
//                         // struct Neighborhood -- const static int MAX_NEIGHBORS = 64; // by grid definition || global variable ||particle.h
//                         if (nh[i].numNeighbors < MAX_NEIGHBORS) // 0 < 64
//                         {
//                             //cout << nh[i].numNeighbors << endl; //-- 0,1,2,3,4,5,6,7,8,9,10,11 dentro del ciclo for hasta aproximadamente 11
//                             nh[i].neighborhoodList[nh[i].numNeighbors] = grid[ii+jj]; // el valor de &pj se asigna nh
                            
//                            // nh[i].neighborhoodList[nh[i].numNeighbors].position = nodeList[i].position;
//                            // nh[i].neighborhoodList[nh[i].numNeighbors].masa = nodeList[i].masa;
                            
//                             nh[i].r[nh[i].numNeighbors] = r; // double r = sqrt(r2);
                            
//                             ++nh[i].numNeighbors; // aumenta en una unidad hasta aproximadamente 11 dentro de este ciclo
                            
                            
//                         }
//                     }
//                 }
//             }

//             nodeList[i].densidad = dens;
//             //cout << pi.d << endl;
//             nodeList[i].densidad_v = dens_proj;
//             //cout << pi.d << endl;
//             nodeList[i].presion = STIFFNESS * (dens - nodeList[i].masa * REST_DENSITY);
//             //cout << pi.p << endl;
//             nodeList[i].presion_v = STIFF_APPROX * dens_proj;
//             //cout << pi.pv << endl;
//             //cout << "salto" << endl;


//           }
//           print("--------------FIN ciclo PRESSURESTEP--------------");

//           print("--------------INICIO ciclo PROJECT--------------");
//           // Project --------------------------------------------------
//           for (int i = 0; i < nodeList.length; i++)
//           {
//               //var p_i = nodeList[i];//guarda el valor de la particula no una copia &, modifica el valor original

//               //Vector2 xx = p_i.position; // guarda posicion de particula evaluada
//               Vector2 xx = Vector2(nodeList[i].position.dx, nodeList[i].position.dy); // guarda posicion de particula evaluada

//               // static vector<Neighborhood> nh(numParticles);
//               for (int j = 0; j < nh[i].numNeighbors; j++) // para cada uno de los vecinos de la particula de la coleccion
//               {
//                   //GenericParticle pj = nh[i].neighborhoodList[j]; //la variable pj de tipo particula tomara el valor del vecino j de la coleecion de vecino de i
//                   double r = nh[i].r[j]; // variable vector r almacena la posicion correspoindiente a j en el rango declarado dentro de la estructura Neighborhood correspondiente a nh r(MAX_NEIGHBORS)
//                   //cout << r << endl;// 0.18,0.09,0.127,0.18,0.09,0.127,0.09,0.09,0.18,0.18,0.18 ...
//                   Offset dx_0 = nh[i].neighborhoodList[j].position - nodeList[i].position; // distancia entre particula i y particula vecina j // offset
//                   Vector2 dx = new Vector2(dx_0.dx, dx_0.dy); // distancia entre particula i y particula vecina j // vector

//                   double a = 1.0 - r / H;
                  
//                   // const static double DT2 = DT * DT; //variable global
//                   // double pv; // variable de la clase Particle // variante de presion
//                   // double p;  // variable de la clase Particle //  presion
//                   double d = DT2 * ((nodeList[i].presion_v + nh[i].neighborhoodList[j].presion_v) * a * a * a * KERN_NORM + (nodeList[i].presion + nh[i].neighborhoodList[j].presion) * a * a * KERN) / 2.0;

//                   // relaxation
//                   // double m;  // variable de la clase Particle //  masa
//                   xx -= (dx * d) / (nodeList[i].masa * r );

//                   // surface tension applies if the particles are of the same material
//                   // this would allow for extensibility of multi-phase
//                   if (nodeList[i].masa == nh[i].neighborhoodList[j].masa)
//                       xx += dx * ((SURFACE_TENSION / nodeList[i].masa) * nh[i].neighborhoodList[j].masa * a * a * KERN) ;

//                   // linear and quadratic visc
//                   // Vector 2d v; // velocity // clase particle
//                   Offset dv_offset = nodeList[i].velocidad - nh[i].neighborhoodList[j].velocidad;
//                   Vector2 dv = new Vector2(dv_offset.dx, dv_offset.dy);
//                   double u = dv.dot(dx); // producto escalar de vector2d dv con dx
                  
//                   print(dv);
//                   print(dx);
//                   print(u);

//                   if (u > 0)
//                   {
//                       u /= r;
//                       double a = 1 - r / H;
//                       double I = 0.5 * DT * a * (LINEAR_VISC * u + QUAD_VISC * u * u);
//                       xx -= dx * (DT * I);
//                   }
//               }
//               //static vector<Vector2d> xprojected(numParticles); // variable global
//               xprojected[i] = xx; // relaxation
//           }
//           print("--------------FIN ciclo PROJECT--------------");
          
         
//           print("--------------INICIO ciclo CORRECT--------------");
//           for (int i = 0; i < nodeList.length; i++) // para cada particula 
//               {
//                 //auto& p = particles[i];// dada una particula de la coleccion matriz particulas asignar variable p
//                 Offset relax = Offset(xprojected[i][0],xprojected[i][1]);
//                 nodeList[i].position = relax; // posicion de la particula igual a xprojected (relaxation) calculado en funcion project
//                 nodeList[i].velocidad = (nodeList[i].position - xlast[i]) / DT; // velocidad igual a la posicion menos posicion anterior dividido entre el tiempo
//               }
//           print("--------------FIN ciclo CORRECT--------------");
          
          
//           print("--------------INICIO ciclo GRIDINSERT 2--------------");
//           for (int i=0 ,j = MAX_PARTICLES; i < nodeList.length; i++,j++){

            
//             int indice = j-MAX_PARTICLES;  
//             //print(indice);// para el caso de 5 * 5 es una numeracion de 0 a 24 (25 particulas en total)
//             //var p = nodeList[i]; // toma una particula
//             double px = nodeList[i].position.dx / CELL_SIZE;
//             /* double d = 20.5; // ejemplo
//             int i = d.toInt(); // i = 20
//             int i = d.round(); // i = 21
//             int i = d.ceil();  // i = 21
//             int i = d.floor(); // i = 20
//             */
//             int xind = px.toInt();
//             //print("--xind--");
//             //print(xind);

//             //print(xind);
//             // print (p.position.dx);
//             // print (CELL_SIZE);
//             // print (xind);
//             // print ("SALTO");
//             // print ("SALTO");

//             double py = nodeList[i].position.dy / CELL_SIZE;

//             //int yind = py.floor();
//              int yind = py.toInt();
//             //  print("analisis yind");
//             //print(CELL_SIZE);
//            //print(nodeList[i].position.dy);
//             //print(py);
//             //  print(yind);
//             // print(yind);
//             //  print (p.position.dy);
//             //  print (CELL_SIZE);
//             //  print (yind);
//             //  print ("SALTO");
//             // print ("SALTO");

//             /* Flutter Dart Find Minimum Number Value Between Two Numbers           
//               int A = 120;
//               int B = 110;
//               int C;
//               int D;

//               // Finding Minimum Value.
//               C = min(A, B);
//               D = max(A, B);

//               // Finding Minimum Value.
//               C = min(A, B);
//               D = max(A, B);            
//             */
//             xind = max(1,(min(GRID_WIDTH - 2, xind)));
//             yind = max(1,(min(GRID_HEIGHT - 2, yind)));

//             //print("yind");
//             //print(yind);

//             //print("--NUMERO GUIA--");
//             print("xind + yind * GRID_WIDTH");
//             print(xind + yind * GRID_WIDTH);
            
//             nodeList[i].n = grid[xind+yind*GRID_WIDTH]; // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
//             //print("ANTES-----------------------------nodeList[i].nulidad");
//             //print(nodeList[i].nulidad); //FALSE
//             //nodeList[i].n = grid[xind+yind*GRID_WIDTH];

//             grid[xind + yind * GRID_WIDTH].position = nodeList[i].position;
//             grid[xind + yind * GRID_WIDTH].velocidad = nodeList[i].velocidad;
//             grid[xind + yind * GRID_WIDTH].masa = nodeList[i].masa;
//             grid[xind + yind * GRID_WIDTH].densidad = nodeList[i].densidad;
//             grid[xind + yind * GRID_WIDTH].densidad_v = nodeList[i].densidad_v;
//             grid[xind + yind * GRID_WIDTH].presion = nodeList[i].presion;
//             grid[xind + yind * GRID_WIDTH].presion_v = nodeList[i].presion_v;
//             grid[xind + yind * GRID_WIDTH].nulidad = true; // default value false
            
//             //print("DESPUES-----------------------------nodeList[i].nulidad");
//             //print(nodeList[i].nulidad); // FALSE
            
//             //grid[xind + yind * GRID_WIDTH].n = nodeList[i].n; // guardar dentro de var n la var n de nodelist que es ella misma(grid)

//              // guardar genericparticle grid en variable n tipo genericparticle dentro de nodelist
            
//             gridIndices[indice] = Vector2(xind.toDouble(), yind.toDouble()); //var gridIndices = List<Vector2>.filled(MAX_PARTICLES, Vector2(0.0,0.0)); // lista con 25 elementos tipo vector inicializados en 0

//           }
//           print("--------------FIN ciclo GRIDINSERT 2--------------");
//           print("--------------INICIO ciclo ENFORCEBOUNDARY--------------");

//           for (int i = 0; i < nodeList.length; i++)
//           { // para cada particula
//               for (int i = 0; i < boundaries.length; i++) // static vector<Vector3d> boundaries = vector<Vector3d>(); // variable global
//               {//var boundaries = List<Vector3>.filled(MAX_PARTICLES, Vector3(0.0,0.0,0.0)); // lista con 25 elementos tipo vector3 inicializados en 0
//                 double d = nodeList[i].position.dx * boundaries[i][0] + nodeList[i].position.dy * boundaries[i][1] - boundaries[i][2];
//                 // cout << b(0) << endl;
//                 // cout << b(1) << endl;
//                 // cout << b(2) << endl;
//                 // cout << "salto" << endl;
//                 //yind = max(1,(min(GRID_HEIGHT - 2, yind))); ejemplo max
//                   if ((d = max(0.0, d)) < PARTICLE_RADIUS)
//                     {
//                       Offset boundarieAux = Offset(boundaries[i][0] / DT, boundaries[i][1] / DT);
//                       nodeList[i].velocidad += boundarieAux *(PARTICLE_RADIUS - d);
//                     }
//               }
//         }
//         print("--------------FIN ciclo ENFORCEBOUNDARY--------------");



//       }
//     }
      
//     )
//       ..repeat();
//   }

//   @override
//   Widget build(BuildContext context) {
//     return new Container(
//       child: new AnimatedBuilder(
//         animation: animationController,
//         builder: (context, child) => new CustomPaint(
//               size: widget.screenSize,
//               painter: new _DemoPainter(widget.screenSize, nodeList),
//             ),
//       ),
//     );
//   }
// }


// class _DemoPainter extends CustomPainter {
//   final List<Node> nodeList;
//   final Size screenSize;
//   var counter = 0;

//   _DemoPainter(this.screenSize, this.nodeList);

//   @override
//   void paint(Canvas canvas, Size size) {
//     for (var node in nodeList) {
//       node.display(canvas);
//     }
//   }

//   @override
//   bool shouldRepaint(_DemoPainter oldDelegate) => true;
// }


// class Node {
//       int id;
//       Size screenSize;
//       double size;
//       Random random;
//       Paint notePaint, linePaint;
      
      
//       // position, velocity, and mass
//       Offset position; // x
//       Offset velocidad; // v
//       double masa; // m
//       // pressure, density, and their variations
//       double densidad;
//       double densidad_v;
//       double presion;
//       double presion_v;
//       Offset viscosidad;
    
      
//       int numNeighbors;
//       bool nulidad;
//       GenericParticle n;

//   Node(
//       {
//       @required this.id,
//       @required this.screenSize,
//       @required this.size,//Tamaño del punto 
//       @required this.position,
//       @required this.velocidad,
//       @required this.n,
      
      
//       this.masa = 1.0,
//       this.presion = 0.0,
//       this.presion_v = 0.0,
//       this.densidad = 0.0,
//       this.densidad_v = 0.0,
      
//       this.nulidad = true,
      
//       }) {
   
//     random = new Random(); 
   

//     notePaint = new Paint()
//       ..color = Colors.blue;
//       //..strokeWidth = 3.0 // ancho del contorno del circulo relacionado con style
//       //..maskFilter = MaskFilter.blur(BlurStyle.solid, 3.0) // desemfoque, QUITA RENDIMIENTO
//       //..style = PaintingStyle.stroke; // circulo relleno o vacio
    
    
//     linePaint = new Paint()
//       ..color = Colors.blueAccent
//       ..strokeWidth = 0.5
//       ..style = PaintingStyle.stroke;
//   }

 
//    void display(Canvas canvas) {
//      canvas.drawCircle(position, size, notePaint);
//     }

//   bool operator ==(o) => o is Node && o.id == id;
//   int get hashCode => id;
// }


// class Neighborhood {
  
  
  
//         // position, velocity, and mass
//         Offset position;      // x
//         Offset velocidad;     // v
//         double masa;          // m
//         // pressure, density, and their variations
//         double densidad;      // d
//         double densidad_v;    // dv
//         double presion;       // p
//         double presion_v;     // pv

//         List<GenericParticle>neighborhoodList; // Particles      
//         int numNeighbors;
//         List<double> r;

  

//  Neighborhood(
//       {
      
      
//         @required this.neighborhoodList ,
//         @required this.position,
//         @required this.velocidad,
//         @required this.r,
                
//         this.masa = 0.0,
//         this.presion = 0.0,
//         this.presion_v = 0.0,
//         this.densidad = 0.0,
//         this.densidad_v = 0.0,
        

       
//         this.numNeighbors = 0,
        

//       }) {  }

// }

// class GenericParticle { // grid
  
//         // position, velocity, and mass
//         Offset position;      // x
//         Offset velocidad;     // v
//         double masa;          // m
//         // pressure, density, and their variations
//         double densidad;      // d
//         double densidad_v;    // dv
//         double presion;       // p
//         double presion_v;     // pv
              
//         int numNeighbors;
//         bool nulidad;

//         GenericParticle2 n;
        
//       GenericParticle( //
//         {

//         @required this.position,
//         @required this.velocidad,
//         @required this.n,
                        
//         this.masa = 0.0,
//         this.presion = 0.0,
//         this.presion_v = 0.0,
//         this.densidad = 0.0,
//         this.densidad_v = 0.0,
//         this.numNeighbors = 0,
//         this.nulidad = false
        
//         }) 
//           { } // para inicializar variables o modificarlas
//           //void move(){} // funciones de la clase ejemplo: move
//     }


// class GenericParticle2 { // grid
  
//         // position, velocity, and mass
//         Offset position;      // x
//         Offset velocidad;     // v
//         double masa;          // m
//         // pressure, density, and their variations
//         double densidad;      // d
//         double densidad_v;    // dv
//         double presion;       // p
//         double presion_v;     // pv
              
//         int numNeighbors;
//         bool nulidad;

        
        
//       GenericParticle2( //
//         {

//         @required this.position,
//         @required this.velocidad,
                               
//         this.masa = 0.0,
//         this.presion = 0.0,
//         this.presion_v = 0.0,
//         this.densidad = 0.0,
//         this.densidad_v = 0.0,
//         this.numNeighbors = 0,
//         this.nulidad = false
        
//         }) 
//           { } // para inicializar variables o modificarlas
//           //void move(){} // funciones de la clase ejemplo: move
//     }

*/